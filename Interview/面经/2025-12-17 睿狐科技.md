# 受控组件与非受控组件区别

对于 input 输入而言，  
**受控组件**就是通过 state 管理输入值，onChange 更新页面 state  
**场景**：表单实时验证，登陆表单控制密码是否明文显示  

**非受控组件**，由浏览器自己控制输入，ref 操纵真实 dom 获取数据，不会触发 react 状态 更新  
**优势**：比 state 更新渲染快一点点  
**场景**：表单简单输入  

---

# 渲染列表为什么要加 key

**原因是**：  
- 避免状态混乱（如输入框内容错位，本质是错误复用 DOM）；  
- 提升渲染性能（精准识别元素，减少 DOM 操作）；  

1000 个 item，如果索引做 key 或者不加，删除第一个，重新渲染 999 个虚拟 dom  

**正确处理列表变化**  
diff 算法比较列表子项的 key --- 虚拟 DOM 节点的唯一标识  
- 若新旧节点 key 相同：React 认为是「同一个元素」，会复用原有 DOM 节点，仅更新节点的 props（如 `value`、`className` 等）；  
- 若新旧节点 key 不同：React 会销毁旧 DOM 节点，创建新的 DOM 节点。  

**输入框内容错位原因**是，比较的时候，删除第一个 item，虚拟 dom 更新前后都是索引 0，复用 input 的 dom 节点，只改变 props，因此 input 值依然是删除掉第一个 item 的值  

---

# 哈希路由，history 路由

- [ ] 哈希路由 URL 含 `#`，History 路由不含 `#` 后内容不发送到服务器 → 服务器永远返回 `index.html`  
- [ ] history 路由不配置重定向：服务器会尝试找 `/about.html` → 不存在 → 404  
- [ ] 哈希路由不需要服务器配置，History 路由需要 配置重定向  
- [ ] History 路由 SEO 更好，哈希路由 SEO 较差  
- [ ] 哈希路由兼容性更好（IE11 支持）  
- [ ] 企业级应用推荐 History 路由  

**两者都是前端来处理路由跳转，但是前提服务器无论从哪个路径进入，都是返回 index html 给前端**  

- 对 hash，`#` 后面路径不处理，默认返回 index.html  
- 对 history 用户访问 `https://your-site.com/about`  
  - 服务器看到请求 `/about` → 重定向到 `index.html`，不重定向就是找 `/about.html`  
  - 浏览器加载 `index.html` → 前端路由解析 `/about` → 渲染 About 组件  

**两者路由跳转机制**  
```javascript
// 改变URL哈希（不触发页面刷新）
window.location.hash = '/about'; // URL变成 #/about

// 使用History API改变URL（不触发页面刷新）
history.pushState(null, '', '/about'); // URL变成 /about
```

---

# cookie 多了哪几个新属性，token 和 cookie 如果作为存储认证信息的 api，各自应用场景是什么

| 属性       | 作用                  | 安全价值                   | 示例                                         | 为什么重要                     |
| -------- | ------------------- | ---------------------- | ------------------------------------------ | ------------------------- |
| SameSite | 防止 CSRF 攻击 （跨站请求伪造） | ✅ 必须设置！                | SameSite=Strict SameSite=Lax SameSite=None | 旧版 Cookie 无此属性，CSRF 是高危漏洞 |
| Secure   | 仅通过 HTTPS 发送        | ✅ 必须与 SameSite=None 组合 | Secure;                                    | 防止中间人攻击（HTTP 明文传输）        |
| HttpOnly | 禁止 JavaScript 访问    | ✅ 认证 Cookie 必备         | HttpOnly;                                  | 防止 XSS 窃取 Cookie          |
| Max-Age  | 设置相对过期时间 （秒）        | ⚠️ 替代 Expires          | Max-Age=3600;                              | 更精确的过期控制                  |
| Domain   | 指定域名范围              | ✅ 避免跨域泄露               | Domain=example.com;                        | 限制 Cookie 作用域             |

**应用场景**  
- 多用于 spa 应用 移动应用：因为用户很多，因此适合把认证信息存在客户端，减轻服务端压力  
- 前后端分离情况下，前后端域名可能完全不一样：  
  - cookie 只支持同源或者跨子域传输认证信息 `example.com` → `api.example.com`  
  - 跨主域名 → 必须用 Token `example.com` → `api.another.com`  

---

# ssr 是什么

SSR（服务端渲染）：服务器在用户请求时，直接生成完整的 HTML 页面，再发送给浏览器（用户打开页面瞬间看到内容，无需等待 JS 加载）  

**优点**：  
- 首屏加载快 --- 直接返回 html 不需要加载 js  
- 搜索引擎友好 ---- 搜索引擎爬虫（如 Google）无法执行 JavaScript, 只能识别 html  

---

# ssr 会有一个水合步骤，那水合失败是什么情况

- **服务器与客户端内容不一致**：ssr 里使用 math.random，new date（）都会出现  
- **依赖浏览器 API 的代码**：ssr 里使用 window --- SSR 环境没有 window  
- **数据不一致**：服务器渲染时用的是预取数据，客户端用的是实时数据，两者不同  
  - 服务器渲染：`Alice`  
  - 客户端渲染：`Bob`（最新数据）不同则报错  

```javascript
// 服务器端返回数据
export async function getServerSideProps() {
  return { props: { data: { name: "Alice" } } };
}

// 客户端获取最新数据
useEffect(() => {
  fetch('/api/data').then(res => res.json()).then(data => setUserData(data));
}, []);
```

**水合失败解决方案**：环境判断（window 不为空才执行） + 用 state 管理动态内容（ssr 渲染的赋初始值，csr 的 useEffect 在更新状态）