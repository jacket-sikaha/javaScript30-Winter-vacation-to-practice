面试题链接:https://juejin.cn/post/7578460753211162651?searchId=20251203160438B9CEA9B56AD78479A50B

#### 前端需要注意哪些SEO

一句话：**语义化HTML是地基，元信息是门牌，速度是门槛，图片Alt是说明，SPA要SSR**

前端SEO的核心目标：让搜索引擎的爬虫能像人一样读懂你的页面内容
语义化HTML---元信息优化（Title,Description）--优化图片格式添加alt说明--用ssr渲染出适合seo的内容

#### HTTP的几种请求方法用途

RESTful API设计原则---大致用途

- **CREATE** → POST
- **READ** → GET
- **UPDATE** → PUT（全量）或 PATCH（部分）
- **DELETE** → DELETE
  get 和post 参数位置一个在url ，一个在请求体body；
  传输数据大小post 比get多

#### 从浏览器地址栏输入url到显示页面的步骤

- URL解析（浏览器的"读菜单"
- DNS解析（"找地址"） 解析顺序：
  1.  浏览器缓存
  2.  操作系统缓存 host 文件
  3.  本地DNS服务器
  4.  根DNS服务器 → 顶级域名服务器 → 权威DNS服务器
- TCP连接-建立可靠通信通道
- HTTP请求与响应-客户端向服务器请求资源
- 页面渲染1. **HTML解析** → 构建DOM树2. **CSS解析** → 构建CSSOM树3. **DOM + CSSOM** → 构建Render树4. **Layout**（回流）→ 计算位置和大小 5. **Paint**（重绘）→ 绘制像素 6. **Composite**（合成）→ 合并图层
  注意点：
  JS可能修改DOM结构，浏览器需要确保JS执行前DOM已构建完成，所以会暂停解析直到JS执行完毕
  CSS加载会阻塞渲染，但不会阻塞DOM构建

#### 如何进行网站性能优化

#####  1. **减少HTTP请求（基础中的基础）**

- **为什么**：每次请求都有DNS、TCP握手延迟（平均100ms+）
- **怎么做**：
  - 合并CSS/JS文件（如Webpack打包）
  - 用CSS雪碧图（Sprite）合并小图标
  - 静态资源用CDN分发（如阿里云CDN）

##### 📌 2. **压缩资源大小（最直接有效）**

- **为什么**：带宽有限，小文件传输更快
- **怎么做**：
  - 启用Gzip/Brotli压缩（服务器配置）
  - 图片用WebP格式（比JPEG小30%+）
  - CSS/JS用UglifyJS压缩（删除注释、空格）

##### 📌 3. **合理利用缓存（让浏览器当"熟人"）**

- **为什么**：缓存让浏览器直接用本地资源，不用重复请求
- **怎么做**：
  - 设置`Cache-Control: max-age=31536000`（一年缓存）
  - 静态资源加版本号（如`style.v2.css`）
  - 首页用Service Worker做离线缓存

##### 📌 4. **优化关键渲染路径（首屏速度是王道）**

- **为什么**：用户最关心"首屏加载"，优化首屏能提升感知速度
- **怎么做**：
  - CSS放`<head>`（避免FOUC闪屏）
  - JS放`<body>`底部或用`async`/`defer`
  - 内联关键CSS（首屏必要样式）

##### 📌 5. **懒加载非关键资源（按需点餐）**

- **为什么**：非首屏内容（如图片、视频）不需要立即加载
- **怎么做**：
  - 图片用`loading="lazy"`（原生懒加载）
  - 滚动时加载（Intersection Observer API）
  - 视频用`preload="none"`

#### HTTP状态码及其含义

1. [ ]  1xx: 信息性响应（100, 101, 102）
2. [ ]  2xx: 成功（200, 201, 204, 206）
3. [ ]  3xx: 重定向（301, 302, 304, 307, 308）
4. [ ]  4xx: 客户端错误（400, 401, 403, 404, 405, 429）
5. [ ]  5xx: 服务器错误（500, 502, 503, 504

- 400: 请求格式错误
- 401: 未认证（需要登录）
- 403: 已认证但无权限
- 404: 资源不存在
- 500: 服务器内部错误（最常见）
- 502: 网关错误（代理服务器问题）
- 503: 服务暂时不可用（过载或维护）
- 504: 网关超时（上游服务响应慢）
- 301是永久重定向，302是临时重定向

#### 介绍一下你对浏览器内核的理解

内核就是渲染引擎，负责解析和渲染网页
现代浏览器内核分为几个线程共同完成渲染

1. **网络线程**下载HTML/CSS/JS
2. **主线程**解析HTML → DOM树
3. **主线程**解析CSS → CSSOM树
4. **主线程**合并DOM+CSSOM构建Render树 → 布局（Layout）
5. **合成线程**将Render树拆分为图层 → **光栅线程**转化为像素 → **GPU**显示

#### html5有哪些新特性、移除了那些元素

语义化标签
多媒体原生支持 无需Flash
localStorage，sessionStorage
表单增强，输入类型支持数字，邮箱
支持地理位置api，websocket

#### link与@import 的区别

1. [ ]  **加载时机**：link立即加载，@import延迟加载（CSS解析后才加载）
2. [ ]  **兼容性**：link兼容所有浏览器，@import在IE8以下不支持
3. [ ]  **使用位置**：link在HTML中，@import在CSS中
4. [ ]  **性能**：link提升首屏速度，@import可能卡页面
5. [ ]  **优先级**：@import可能被覆盖（css里后引入的覆盖先引入），link优先级可控

#### 什么是FOUC?如何避免

**FOUC（Flash of Unstyled Content）是浏览器先显示无样式HTML内容，再加载CSS后突然变样，导致页面"闪一下"的糟糕体验**

1. FOUC是CSS加载延迟导致的页面闪烁
2. [ ]  根本原因：CSS未在渲染前加载
3. [ ]  避免方法：CSS放`<head>` + 内联关键CSS
4. [ ]  禁用`@import`（它会加重FOUC）
5. [ ]  现代方案：关键CSS内联 + `rel="preload"`

#### 如何创建块级格式化上下文(block formatting context)

1. BFC是独立的布局环境，解决浮动和margin问题
2. [ ]  5种触发方式：浮动 float 不推荐、定位 absolute、fixed、根元素、display如flex grid、overflow
3. [ ]  `overflow: hidden`是首选方案（安全且不破坏布局）
4. [ ]  BFC与IFC的区别：BFC是块级布局，IFC是行内布局
5. [ ]  实际应用：清除浮动（父元素高度塌陷）、避免上下div的margin重叠

#### 说说你对闭包的理解

闭包的形成条件

1. **内层函数**（嵌套在另一个函数内部）
2. **引用外层变量**（使用了外部函数的变量）
3. **外层函数返回内层函数**（或将其暴露到外部）

**持久作用域**---外部函数执行完仍能访问外层变量

**私有状态**--只有内部函数访问得了

#### 说说你对作用域链的理解

##### **作用域链的结构（三层模型）**

每个函数的作用域链包含：

1. **自身作用域**（Local/Function Scope）
2. **所有外层函数的作用域**（按嵌套顺序向上）
3. **全局作用域**（Global Scope）

- 作用域链是闭包能“记住”变量的根本原因
- 变量查找规则（三个结构依次从内向外）

#### JavaScript原型，原型链？有什么特点

##### **原型 vs 原型链（核心区别）**

| 概念                      | 本质                                   | 作用                    |
| ------------------------- | -------------------------------------- | ----------------------- |
| **原型（`prototype`）**   | **函数的属性**（如`Person.prototype`） | 定义对象的共享属性/方法 |
| **原型链（`__proto__`）** | **对象的属性**（如`john.__proto__`）   | 属性查找的路径          |

对象**proto**指向构造函数prototype，构造函数prototype的construct指向其构造函数，

原型链的查找规则（3步走）
当访问对象属性时：

先查自身（obj.property）
再查原型（obj.**proto**.property）
直到Object.prototype（终点！）

##### **原型链的终点（关键！）**

- **`Object.prototype`** 是所有对象的最终原型
- **`Object.prototype.__proto__ === null`**（链的终点）

##### **原型的核心优势**

**内存优化** ，**动态继承** 在原型上定义方法，所有实例都能用，不需要一个个定义，这里就很像实现了继承

#### instanceof

`instanceof` 是用来判断一个对象是否是由某个构造函数（或其父类）创建的实例，其原理是沿着对象的原型链向上查找，看能否找到构造函数的 `prototype` 对象

| 对比项 | `typeof`                                           | `instanceof`                             |
| ------ | -------------------------------------------------- | ---------------------------------------- |
| 用途   | 判断基本类型（string/number/boolean等）            | 判断引用类型（对象是否由某构造函数创建） |
| 返回值 | 字符串（如 `"object"`）                            | 布尔值（true/false）                     |
| 局限   | 无法区分 Array、Date、null 等（都返回 `"object"`） | 只对对象有效，对基本类型一律返回 false   |

#### 请解释什么是事件代理

本质：利用事件冒泡，由父元素统一处理子元素事件，不需要每个子元素都绑定一个监听事件
运行流程：事件三要素：捕获 目标 冒泡，父元素的事件触发后通过event.target.match方法来捕获具体哪个子元素触发
优势：一个监听事件解决，节省内存，对于动态变化的子元素添加监听事件依然有效

#### Javascript如何实现继承

##### 继承方案对比表

| 方案         | 属性共享 | 方法复用 | 传参 | 调用次数 | 推荐度     |
| ------------ | -------- | -------- | ---- | -------- | ---------- |
| 原型链       | ❌       | ✅       | ❌   | 1次      | ⭐         |
| 借用构造     | ✅       | ❌       | ✅   | 1次      | ⭐⭐       |
| 组合继承     | ✅       | ✅       | ✅   | **2次**  | ⭐⭐⭐     |
| **寄生组合** | ✅       | ✅       | ✅   | **1次**  | ⭐⭐⭐⭐⭐ |
| ES6 Class    | ✅       | ✅       | ✅   | 1次      | ⭐⭐⭐⭐   |

原型链：子类原型 =》 父类实例（会存在问题 所有子实例共享父实例的引用属性）
借用构造：借用父类构造函数，将属性绑定到当前实例上（没有原型链链接到父类原型，无法继承父类方法）
组合继承：前两种结合，借用构造设置父类属性，原型链继承父类方法
缺点：父构造函数被调用两次（浪费性能）
寄生组合:用 Object.create() 避免调用 Parent()1次，创建了一个父类原型（Parent.prototype）f副本，让子类原型的`__proto__`能指向真正的Parent.prototype

#### new操作符具体干了什么呢

- 创建新对象obj
- 设置 `obj.__proto__ = 构造函数.prototype`
- call方法调用构造函数，this指向obj
- 返回obj

#### Ajax原理

XMLHttpRequest 这个api控制
通过发送http请求，异步，不需要刷新页面就获取服务器返回的数据

##### **Ajax工作流程（4步走）**

| 步骤                |     |     |
| ------------------- | --- | --- |
| **1. 创建请求对象** |     |     |
| **2. 设置回调函数** |     |     |
| **3. 发送请求**     |     |     |
| **4. 处理响应**     |     |     |
|                     |     |     |

```js
const xhr = new XMLHttpRequest();
xhr.open("GET", "https://api.example.com/user");
xhr.onload = function () {
  if (xhr.status === 200) {
    const user = JSON.parse(xhr.responseText); // 解析外卖内容
    document.getElementById("name").textContent = user.name; // 更新页面
  }
};
xhr.send();
```

##### **现代替代方案：Fetch API（更简洁）**

支持promise
不需要手动处理状态

#### 如何解决跨域问题

- 一般情况下图片等静态资源不受跨域影响
- 浏览器同源问题：同协议 同host 同端口
- jsonp
  利用 `<script>` 标签不受同源策略限制的特性
  服务端按jsonp形式返回一个回调函数callback ，让客户端调用获取到返回到数据
  只支持get方法，不安全，但兼容性好
- cors 服务端设置响应头 allow origin methods headers
- proxy 本地代理方式 ，服务端之间通信不受跨域影响
- 线上 nginx 反向代理 ，都是/a 路径 rewrite 成 服务端url

#### 谈谈变量提升

var声明和函数声明会被"移动"到作用域顶部,用let、const替代var，避免变量提升，在赋值前使用变量导致异常

#### bind、call、apply 区别

call都接收 若干参数 ，而apply 接收的是参数数组
bind 是返回改变this指向的新函数，call 和 apply是直接执行

#### 怎么判断对象类型

对于基本数据类型 typeof
对于引用类型 数组isarray ， Object.prototype.toString

#### 箭头函数的特点

this指向为外1层上下文的this
不能用作构造函数 不能new
没有自己的 arguments

#### this

this指向的三种情况
函数调用

```js
// 情况1：函数独立调用 → this = window (浏览器)
function sayHi() {
  console.log(this); // 👉 浏览器：window
}
sayHi();

// 情况2：作为对象方法调用 → this = 对象
const person = {
  name: "小明",
  greet: function () {
    console.log(this.name); // 👉 小明
  },
};
person.greet();

// 情况3：在事件处理中 → this = 触发事件的DOM
<button onclick="console.log(this)">点我</button>; // 👉 <button>元素
```

箭头函数继承外层作用域的this
构造函数
指向new 的实例对象

#### cookie和localSrorage、session、indexDB 的区别

Cookie = 你的"身份证"（服务器要查，随身带）  
localStorage = 你的"日记本"（自己存，不给服务器看）  
sessionStorage = 你的"临时便签"（关浏览器就扔）  
IndexedDB = 你的"家庭数据库"（存照片/文档，超大容量）

| 类型               | 会随HTTP请求发送到服务器吗？ | 为什么             | 代码示例                                 |
| ------------------ | ---------------------------- | ------------------ | ---------------------------------------- |
| **Cookie**         | ✅ **会**（默认）            | 服务器用它识别用户 | `document.cookie = "theme=dark";`        |
| **localStorage**   | ❌ **不会**                  | 仅存客户端         | `localStorage.setItem("theme", "dark");` |
| **sessionStorage** | ❌ **不会**                  | 仅存当前标签页     | `sessionStorage.setItem("cart", "123");` |
| **IndexedDB**      | ❌ **不会**                  | 仅存客户端         | `indexedDB.open(...)`                    |

##### **存储大小（容量对比）**

| 类型               | 最大容量 | 为什么           | 真实场景                           |
| ------------------ | -------- | ---------------- | ---------------------------------- |
| **Cookie**         | 4KB      | 服务器限制       | 一个Cookie存"theme=dark"（10字节） |
| **localStorage**   | 5MB      | 浏览器限制       | 存1000个用户偏好（500字节/个）     |
| **sessionStorage** | 5MB      | 同localStorage   | 存购物车商品ID（500个商品）        |
| **IndexedDB**      | 50MB+    | 浏览览器动态分配 | 存1000张图片（1MB/张）             |

##### **生命周期（存多久？）**

| 类型               | 持久性     | 触发清除条件             | 适用场景              |
| ------------------ | ---------- | ------------------------ | --------------------- |
| **Cookie**         | 可配置     | 设置`expires`或`max-age` | 登录状态（24小时）    |
| **localStorage**   | **永久**   | 手动清除（或用户清除）   | 用户偏好（主题/语言） |
| **sessionStorage** | **会话级** | 关闭浏览器标签页         | 临时购物车            |
| **IndexedDB**      | **永久**   | 手动清除                 | 本地缓存/离线数据     |

##### **使用场景（一图看懂）**

| 场景              | 推荐方案                  | 为什么                 |
| ----------------- | ------------------------- | ---------------------- |
| **用户登录状态**  | ✅ Cookie（带`HttpOnly`） | 服务器需要验证         |
| **网站主题/语言** | ✅ localStorage           | 永久存储，不发给服务器 |
| **临时购物车**    | ✅ sessionStorage         | 关标签页自动清空       |
| **离线图片/缓存** | ✅ IndexedDB              | 大容量，支持查询       |
| **小量会话数据**  | ✅ Cookie（4KB内）        | 无需额外代码           |

#### 判断页面加载完成的5种方法

##### 3个核心概念（先理解再用）

| 概念                                 | 触发时机                             | 适用场景                        | 为什么重要                        |
| ------------------------------------ | ------------------------------------ | ------------------------------- | --------------------------------- |
| **DOMContentLoaded**                 | DOM结构加载完成（无需等待图片/样式） | 需要立即操作DOM（如绑定事件）   | ✅ **最推荐！**（IE9+全面支持）   |
| **document.readyState = 'complete'** | 所有资源（图片/样式/脚本）加载完成   | 需要所有资源就绪（如动画/图表） | ✅ 通用方案（兼容性最好）         |
| **window.onload**                    | 所有资源加载完成（包括图片/iframe）  | 无需立即操作，但需要完整页面    | ❌ 不推荐（比DOMContentLoaded晚） |

readyState 会从loading=》interactive=》complete，且只触发一次

主要有两种可靠方法：1. **DOMContentLoaded事件**，在DOM结构加载完成后触发，不等待图片和样式，是现代Web开发的首选；2. **document.readyState**，可以随时检查页面状态（loading/interactive/complete），适用于需要在不同加载阶段执行操作的场景。`window.onload`虽然也能用，但比DOMContentLoaded晚触发，且可能覆盖其他事件，不推荐作为主要判断方式。
3 vue的mounted方法
4 react的useEffect

#### 说下浏览器缓存

##### 浏览器缓存的类型

### 1. 协商缓存 vs. 强缓存

| 类型         | 工作原理                               | 常用头字段                 | 状态码                                  |
| ------------ | -------------------------------------- | -------------------------- | --------------------------------------- |
| **彻底缓存** | 浏览器直接使用缓存，不向服务器发送请求 | `Cache-Control`, `Expires` | 200 (from cache)                        |
| **缓存协商** | 需要向服务器验证缓存是否有效           | `Last-Modified`, `Etag`    | 200 (from server) 或 304 (Not Modified) |

#### 缓存存储位置

- **内存缓存 (Memory Cache)**：存储在内存中，最快但容量有限，浏览器关闭后清空
- **磁盘缓存 (Disk Cache)**：存储在硬盘上，容量较大，浏览器关闭后仍保留
- **Service Worker缓存**：通过JavaScript实现的高级缓存机制

工作流程
强缓存本地判断，如果缓存有效直接使用，返回状态200，响应头会有`Cache-Control`, `Expires`

- **关键控制头**：- `Cache-Control`: `max-age=3600, public`（缓存有效期3600秒，允许任何缓存存储）- `Expires`: `Wed, 21 Oct 2020 07:28:00 GMT`（绝对过期时间）
- 协商缓存会在请求上携带缓存验证头，服务器认为资源没变化返回200，资源修改了返回304
- **验证机制**：
  - **基于时间**：`Last-Modified` / `If-Modified-Since`
  - **基于内容标识**（优先级更高）：`ETag` / `If-None-Match`

#### vite打包优化

开发阶段几乎不需要优化

- 浏览器直接加载esm模块
- 按需编译所请求文件
- esbuild 依赖预构建
  生产阶段采用rollup 需要优化

减少不必要的依赖处理
✅ 使用 `optimizeDeps.exclude`
跳过不需要预构建的包（如已为 ESM 格式的库）

控制 Rollup 输出配置
✅ 禁用 source map（开发环境可开，生产环境按需开启）

代码分割与懒加载
✅ 合理使用动态导入（自动代码分割） 如路由懒加载，分割页面代码减少主包大小

使用更快的压缩器（实验性）
Vite 默认使用 terser 压缩 JS，但可替换为更快的 esbuild（牺牲少量压缩率换速度）

并行构建（CI/CD 场景）
虽然 Vite 本身不提供多进程构建，但可通过以下方式加速：
使用更快的 CI 机器（更多 CPU）
缓存 node_modules 和 .vite 目录（Vite 会缓存依赖预构建结果）

```yaml
# GitHub Actions 示例
- name: Cache Vite deps
  uses: actions/cache@v3
  with:
    path: |
      node_modules
      .vite
    key: ${{ runner.os }}-vite-${{ hashFiles('**/package-lock.json') }}
```

本质就三个关键词：缓存 拆分 压缩
补充 ：
优化resolve配置，设置路径别名alias
作用：减少路径查找开销，加快模块解析
（但如果是monorepo项目，分包不要使用，主包默认无法解析分包 a 内部的`@`别名（别名是包内隔离的），会导致路径解析失败）
对于自己开发的分包，可以使用exclude 排除不必要的依赖，因为主包一般都有

##### Babel原理详解

Babel是一个JavaScript编译器，其核心原理是将ECMAScript 2015+代码转换为向后兼容的JavaScript语法，以支持旧版本浏览器环境。Babel的工作流程分为**解析、转换、生成**三个关键阶段，整个过程依赖于**抽象语法树（AST）** 作为核心桥梁。

### 工作流程

1. Babel解析源代码为AST
2. 加载配置的插件
3. 遍历AST，调用插件的visitor方法
4. 修改AST
5. 生成目标代码

##### Babel的核心组件

| 组件               | 功能         | 说明                     |
| ------------------ | ------------ | ------------------------ |
| `@babel/parser`    | 源码解析     | 将源代码转换为AST        |
| `@babel/traverse`  | AST遍历      | 遍历AST并应用转换规则    |
| `@babel/types`     | AST节点操作  | 创建、判断、替换节点     |
| `@babel/generator` | 代码生成     | 将AST转换为代码字符串    |
| `@babel/core`      | 核心编译引擎 | 组合其他模块完成编译流程 |

##### Babel的典型应用场景

1. **语法转换**：将ES6+语法转换为ES5
   - 箭头函数 → 普通函数
   - const/let → var
   - class → 构造函数
2. **Polyfill填充**：添加缺失的API实现
   - `Promise`、`Array.from`等
3. **源码转换（codemods）**：自动化代码重构
   - 重命名函数/变量
   - 移除console.log
4. **JSX转换**：将JSX语法转换为React.createElement

优点：无论出了多少新语法，新特性，转成兼容性好的js就能运行，插件化架构，能自定义修改ast从而修改转换逻辑

#### 说一下事件机制、

事件的基本概念

事件是**用户操作网页时发生的交互动作**，

##### 事件三要素

- 触发事件的DOM元素（如按钮、输入框）
- 事件名称（如click、keydown）
- 事件处理：事件触发后执行的函数（回调函数）

###### 事件流：捕获、目标与冒泡

window → 目标元素 事件从根节点向下传播
找到目标触发事件
目标元素 → window 事件从目标元素向上返回

###### 事件监听方式

传统方法获取到dom元素后，element.onclick = function() {}、
缺点同一事件只能绑定一个处理函数
现代方法 addEventListener
能监听多个事件
能控制事件是否冒泡

###### 事件对象与关键方法

##### 事件对象（event）

事件触发时，浏览器会创建一个事件对象，包含事件相关信息和操作方法。

| 属性/方法                 | 说明                             |
| ------------------------- | -------------------------------- |
| `event.target`            | 触发事件的元素（目标元素）       |
| `event.currentTarget`     | 绑定事件的元素（处理事件的元素） |
| `event.stopPropagation()` | 阻止事件传播（冒泡）             |
| `event.preventDefault()`  | 阻止事件默认行为（如链接跳转）   |
| `event.bubbles`           | 是否会冒泡（默认true）           |
| `event.type`              | 事件类型（如'click'）            |

###### 事件委托

利用冒泡机制只需要父元素一个监听就能获取到所有子元素的事件触发

CustomEvent 可以自定义监听事件

#### 浏览器与Node.js中的事件循环机制详解

- **浏览器事件循环**：以"宏任务 → 微任务 → 渲染"为流程，微任务优先于宏任务，支持requestAnimationFrame
- **Node.js事件循环**：以6个阶段的循环为流程，每个阶段后清空微任务，process.nextTick优先级最高

###### 执行流程

1. **执行第一个宏任务（即同步代码）**：
   - 浏览器或Node.js会将整个脚本的同步代码视为第一个宏任务
   - 这些同步代码会立即执行，不会被放入任务队列
2. **执行微任务**：
   - 同步代码执行完毕后，会立即执行所有微任务（如Promise.then）
   - 微任务队列会被清空
3. **执行下一个宏任务**：
   - 微任务执行完毕后，才从宏任务队列中取出下一个任务执行（如setTimeout）

###### nodejs事件循环的6个阶段

- **timer 阶段**：执行 `setTimeout`/`setInterval` 到期的回调
- pending回调阶段\*\*：执行 I/O 操作（如文件、网络）的回调
- **idle/prepare 阶段**：内部使用，无需关注
- **poll 阶段**：事件循环的 “核心等待区”（最关键）
  先执行 poll 队列里的 I/O 回调（文件、网络等）；
  如果 poll 队列为空，会检查是否有 `setImmediate` 回调：
  - 有 → 直接跳到 check 阶段；
  - 无 → 等待新的 I/O 事件，直到有事件触发或到达 timer 阶段的下一个定时器到期时间。
- **check 阶段**：执行 `setImmediate` 的回调
- **close 阶段**：执行 `socket.on('close')` 等关闭回调

1. 同步代码执行：输出"Start"和"End"（宏任务）
2. 清空微任务队列：执行Promise.then，输出"Promise"
3. 进入timers阶段：执行setTimeout回调，输出"Timeout"
4. 进入check阶段：执行setImmediate回调，输出"setImmediate"
5. close 阶段执行完后，事件循环会**回到 timer 阶段**，开启新一轮完整的循环（重新检查定时器、处理 I/O 等）
   setImmediate和setTimeout 顺序不定

#### 说一下进程与线程

| 特性          | 进程                                     | 线程                                  |
| ------------- | ---------------------------------------- | ------------------------------------- |
| 定义          | 程序的一次执行                           | 进程内的执行单元，是CPU调度的基本单位 |
| 内存空间      | 独立的地址空间                           | 共享进程的地址空间                    |
| 资源          | 独立的系统资源（文件描述符、环境变量等） | 共享进程的系统资源                    |
| 创建/销毁开销 | 较大（需要分配内存、创建PCB等）          | 较小（只需创建线程控制块）            |
| 通信方式      | 需要IPC（进程间通信）                    | 直接通过共享内存通信                  |
| 并发性        | 进程间并发                               | 线程间并发                            |
| 安全性        | 相对安全（进程间隔离）                   | 需要同步机制（如锁、信号量）          |
| 崩溃影响      | 一个进程崩溃不影响其他进程               | 一个线程崩溃可能导致整个进程崩溃      |

线程是进程的组合，线程更小，所需资源也小
因为进程间隔离，具备一定安全性，也牺牲了进程间的通信效率。线程反过来

#### 何时选择进程 vs 线程

| 场景                                                     | 推荐方案 | 原因                            |
| -------------------------------------------------------- | -------- | ------------------------------- |
| 需要高稳定性（如浏览器标签页）需要高安全性（如银行系统） | 多进程   | 进程隔离，一个崩溃不影响其他    |
| CPU密集型任务（如图像处理）                              | 多进程   | 充分利用多核CPU，避免GIL限制    |
| I/O密集型任务（如Web服务器）                             | 多线程   | 轻量级，通信简单，提高I/O吞吐量 |
| 需要简单通信（如多线程共享数据）                         | 多线程   | 无需IPC，直接共享内存           |

#### 关键概念

- **并发**：多个任务在同一时间段内执行（可以是交替执行）
- **并行**：多个任务在同一时间点同时执行（需要多核CPU）
- **GIL**：全局解释器锁，限制Python多线程在CPU密集型任务中的性能
- **IPC**：进程间通信，实现进程间数据交换的机制
